#! /usr/bin/env python2.7

# ================================
# Builds a predicate dictionary from the CCG parses
# given in the input file (-i option) and saves it
# to the specified output file (-o option).
# ================================

from __future__ import unicode_literals

import sys
import optparse
import re
import string
import codecs
from collections import defaultdict, namedtuple
from nltk.sem.logic import Expression, Variable
from pprint import pprint

# Local imports
import rules
from predicatelexicon import PredicateLexicon


optparser = optparse.OptionParser()
optparser.add_option("-i", "--infile", dest="infile", default="", help="Input file")
optparser.add_option("-o", "--outfile", dest="outfile", default="", help="Output file")
(opts, _) = optparser.parse_args()

lexpr = Expression.fromstring

def get_parses(infile):
    """
    Read in the parses file.

    param str infile: path to parses file.
    returns list(list) of parses split into dependencies and tags.
    """
    # Open file and split at each parse.
    parses = codecs.open(infile, 'r', 'utf-8').read().split('\n===\n')
    # Split each parse between dependencies and tags.
    parses = [parse.split('\n<c> ') for parse in parses]
    # Split at each dependency.
    parses = [[deps.split('\n'), tags.split()] for (deps, tags) in parses]
    return parses

def preprocess_word(word):
    """
    Makes word NLTK friendly.
    """
    # Remove numeric index.
    word = word.split('_')[0]
    # Remove intraword punctuation.
    for punct in string.punctuation:
        word = word.replace(punct, '')
    return word

def build_catLex(parses):
    """
    Builds lexicon of categories for each word in parses.

    param list(list) parses: output of get_parses().
    returns dict{word: namedtuple(pos_tag, category, dependencies)
    """
    catLex = defaultdict(list)
    MR = namedtuple('MR', 'pos, category, deps') 
    for (deps, tags) in parses:
        depDict = {}
        for line in deps:
            (word, dep, rest) = line.split(' ', 2)
            word = preprocess_word(word)
            if word not in string.punctuation:
                depDict[word] = dep
        for tag in tags:
            (word, pos, cat) = tag.split('|')
            word = preprocess_word(word)
            cat = re.sub(r'\[.*?\]', '', cat)
            mr = MR(pos, cat, depDict.get(word))
            if word not in string.punctuation:
                if mr not in catLex[word]:
                    catLex[word].append(mr)
    return catLex

def getpred(word, dependency):
    """
    Determines Neo-Davidsonian Event semantic representation
    of a word given it's dependecy.

    param str word
    param str dependency: from MR.deps namedtuple.
    returns list of predicates.
    """
    rePar = re.compile(r'\(')  # Left parentheses.
    reXargs = re.compile(r'\{[A-Z]\}(?=<[0-9]>)')  # Argument variables \x

    # Replace the asteriks so that we can match arguments correctly.
    dependency = dependency.replace('*', '')  

    # Determine the number and type of arguments.
    xargs = reXargs.findall(dependency)
    
    mr_string = '\\'
    xarg_chars = []
    parg_chars = []
    for i,_ in enumerate(xargs):
        char = string.ascii_uppercase[i+1]
        parg_chars.append(char)
        mr_string += "{0} ".format(char)
    mr_string += "e. exists "
    for xarg in xargs:
        char = re.sub(r'[\{\}]', '', xarg).lower()
        xarg_chars.append(char)
        mr_string += "{0} ".format(char)
    mr_string += ".("
    for i,char in enumerate(xarg_chars):
        mr_string += "{0}:{1}(e, {2}) & ".format("{0}", i+1, char)
    for i,char in enumerate(reversed(parg_chars)):
        if i+1 == len(parg_chars):
            mr_string += "{0}({1})".format(char, xarg_chars[i])
        else:
            mr_string += "{0}({1}) & ".format(char, xarg_chars[i])
    mr_string += ')'

    return [mr_string]

def build_predLex(catLex):
    """
    Builds the predicate lexicon from the pos tag
    and/or the dependencies for each word in catLex.

    param catLex dict{word: list(MR)}: output of build_catLex.
    """
    quantifiers = ['all', 'exists', 'some']
    wordRules = {
                 'the': rules.def_art,
                 'a': rules.indef_art,
                 'an': rules.indef_art,
                 'is': rules.copula,
                 'be': rules.copula,
                 'am': rules.copula,
                 'are': rules.copula,
                 'was': rules.copula,
                 'were': rules.copula,
                 'not': rules.negate,
                 "nt": rules.negate,
                 "no": rules.no
                }
    posRules = {
                'NNP': rules.const,
                'NNPS': rules.const,
                'PRP': rules.const,
                'NN': rules.const2,
                'NNS': rules.const2,
                'JJ': rules.adj,
                #'RB': rules.adv,
                'CD': rules.num,
                'CC': rules.conj,
                'WDT': rules.what,
                'WRB': rules.what,
                'WP': rules.what,
                'WP$': rules.what
               }

    # If POS tag in depRules, use getpred() function.
    depRules = ['VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ', 'IN', 'TO', 'POS']

    predLex = PredicateLexicon()
    for (word, mrs) in catLex.iteritems():
        if word.lower() in quantifiers:
            continue
        for mr in mrs:
            # Determine the predicate.
            predicates = []
            if word in wordRules:
                predicates.extend(wordRules[word]())
            elif mr.deps and mr.pos in depRules:
                predicates.extend(getpred(word, mr.deps))
            elif mr.pos in posRules:
                predicates.extend(posRules[mr.pos]())
            else:
                sys.stderr.write("No applicable rule for {0} {1} {2}.\n"
                                  .format(word, mr.pos, mr.deps != None))
                break

            # Store the predicate.
            if len(word) == 1:
                # Change words of length 1 so that they don't
                # become VariableExpressions but ConstantExpressions.
                sub = "_{0}".format(word)
            else:
                sub = word
            for predicate in predicates:
                # Make sure each predicate is valid.
                try:
                    lexpr(predicate)
                except:
                    continue
                # Add it to the lexicon.
                if predicate.format(sub.lower()) not in predLex[word]:
                    predLex[word].append(predicate.format(sub.lower()))
                if predicate not in predLex.categories[mr.category]:
                    predLex.categories[mr.category].append(predicate)
    return predLex

def write_predLex(predLex, filename):
    """
    Saves predLex to filename.
    """
    with codecs.open(filename, 'w', 'utf-8') as out:
        out.write('# WORDS\n')
        word_list = sorted(predLex.items(), key=lambda (w,e): w)
        for (word, mrs) in word_list:
            for mr in mrs:
                out.write('{0} :: {1}\n'.format(word, mr))
        out.write('# CATEGORIES\n')
        cat_list = sorted(predLex.categories.items(), key=lambda (c,e): len(c))
        for (cat, mrs) in cat_list:
            for mr in mrs:
                out.write('{0} :: {1}\n'.format(cat, mr))
    print "predLex written to {0}.".format(filename)

def main():
    if not opts.infile or not opts.outfile:
        print "Usage build_predlex [-i <path/to/inputfile>] [-o <path/to/outputfile>]"
        return

    parses = get_parses(opts.infile)
    catLex = build_catLex(parses)
    predLex = build_predLex(catLex)
    write_predLex(predLex, opts.outfile)


if __name__ == '__main__':
    main()
