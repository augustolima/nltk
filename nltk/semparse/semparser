#! /usr/bin/env python2.7

# ============================
# Semantic parser CLI tool.
# ============================

from __future__ import print_function, unicode_literals

import sys
import optparse
import readline  # Needed for shell-style line editing/cmd history.
import re
import string

from nltk import word_tokenize
from nltk.ccg import lexicon, chart
#from nltk.semparse.predicatelexicon import PredicateLexicon
#from nltk.semparse.semanticparser import SemanticParser
from predicatelexicon import PredicateLexicon ##
from semanticparser import SemanticParser ##


optparser = optparse.OptionParser()
optparser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False, help="Show MR derivation")
optparser.add_option("-s", "--syntax", action="store_true", dest="syntax", default=False, help="Show syntactic parse")
optparser.add_option("--ccglex", dest="ccglex", default="", help="CCG lexicon file")
optparser.add_option("--predlex", dest="predlex", default="", help="Predicate lexicon file")
(opts, _) = optparser.parse_args()


class Interpreter(object):

    def __init__(self, ccglex, predlex, syntax=False, semantics=False):
        self.SemParser = SemanticParser(ccglex, predlex)
        self.opt_syntax = syntax
        self.opt_semantics = semantics
        self.status = 'GO'

    def print_welcome(self):
        print("\n---- NLTK Semantic Parser (interactive) ----")
        print("Enter a sentence at the '>' prompt.")
        print(" '!help' to show this message.")
        print(" '!quit' to exit.")
        print(" '!verbose on|off' to show/hide semantic derivation.")
        print(" '!syntax on|off' to show/hide syntactic parse.")
        print(" '!predlex <word>' to show predicates assigned to <word>.\n")

    def parseCmd(self, cmd):
        """
        param str cmd: command to be parsed
        """
        args = cmd.split()
        args.pop(0)  # Strip off command name.

        if cmd == '!quit':
            return self._quit(*args)
        elif cmd == '!help':
            return self._help(*args)
        elif cmd.startswith('!verbose'):
            return self._verbose(*args)
        elif cmd.startswith('!syntax'):
            return self._syntax(*args)
        elif cmd.startswith("!predlex"):
            return self._predlex(*args)
        else:
            print("Unknown command: {0}".format(cmd))
            return 'GO'

    def printSemanticParse(self, semparse):
        if self.opt_syntax:
            print("\n======== SYNTACTIC PARSE ========\n")
            semparse.printSyntacticDerivation()
        if self.opt_semantics:
            print("\n====== SEMANTIC DERIVATION =======\n")
            semparse.printSemanticDerivation()
        print("\n========= SEMANTIC PARSE =========\n")
        print(semparse.expression)

    def run(self):
        while self.status == 'GO':
            try:
                sent = raw_input("> ")
            except EOFError:
                break
            if not sent:
                continue
            # Command
            if sent.startswith('!'):
                self.status = self.parseCmd(sent)
            # Sentence
            else:
                for parse in self.SemParser.parse(sent):
                    self.printSemanticParse(parse)
                    ans = raw_input("ENTER for next or 'q' to stop: ")
                    if ans.lower() == 'q':
                        break


    # ===============================
    #     Interpreter commands 
    # ===============================

    def _quit(self, arg=None):
        return 'STOP'

    def _help(self, arg=None):
        self.print_welcome()
        return 'GO'

    def _verbose(self, arg=None):
        if not arg:
            if self.opt_semantics == True:
                print('On')
            else:
                print('Off')
            return 'GO'
        if arg.lower() == 'off': self.opt_semantics = False
        elif arg.lower() == 'on': self.opt_semantics = True
        else: print("Invalid value: {0}".format(arg))
        return 'GO'

    def _syntax(self, arg=None):
        if not arg:
            if self.opt_syntax == True:
                print('On')
            else:
                print('Off')
            return 'GO'
        if arg.lower() == 'off': self.opt_syntax = False 
        elif arg.lower() == 'on': self.opt_syntax = True 
        else: print("Invalid value: {0}".format(arg))
        return 'GO'

    def _predlex(self, arg=None):
        if not arg:
            return 'GO'
        for (exprs, cat) in self.SemParser.composer.predLex.get(arg):
            for expr in exprs:
                print("{0} -- {1}".format(expr, cat))
        return 'GO'


if __name__ == '__main__':
    if not opts.ccglex or not opts.predlex:
        line = "Usage: semparser [-v] [-s] --ccglex <path/to/file> --predlex <path/to/file>\n"
        sys.stderr.write(line)
        sys.exit(1)

    interpreter = Interpreter(opts.ccglex, opts.predlex,
                              opts.syntax, opts.verbose)
    interpreter.print_welcome()
    interpreter.run()
