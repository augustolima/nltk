#! /usr/bin/env python2.7

# ============================
# Semantic parser CLI tool.
# ============================

import sys
import optparse
import readline  # Needed for shell-style line editing/cmd history.
import re
import string
from nltk import word_tokenize
from nltk.ccg import lexicon, chart
from predicatelexicon import PredicateLexicon
from semanticparser import SemanticParser


optparser = optparse.OptionParser()
optparser.add_option("-v", "--verbose", action="store_true", dest="verbose",
                     default=False, help="Show MR derivation")
optparser.add_option("-s", "--syntax", action="store_true", dest="syntax",
                     default=False, help="Show syntactic parse")
optparser.add_option("--ccglex", dest="ccglex", default="",
                     help="CCG lexicon file")
optparser.add_option("--predlex", dest="predlex", default="",
                     help="Predicate lexicon file")
(opts, _) = optparser.parse_args()


class Interpreter(object):

    def __init__(self, ccglex, predlex, syntax=False, derivation=False):
        trace = sum([1 for opt in [syntax, derivation] if opt])
        self.SemParser = SemanticParser(ccglex, predlex, trace)
        self.status = 'GO'

    def print_welcome(self):
        print "\n---- NLTK Semantic Parser (interactive) ----"
        print "Enter a sentence at the '>' prompt."
        print " '!help' to show this message."
        print " '!quit' to exit."
        print " '!verbose on|off' to show/hide semantic derivation."
        print " '!syntax on|off' to show/hide syntactic parse."
        print " '!predlex <word>' to show predicates assigned to <word>.\n"

    # TODO: clean up parseCmd function.
    def parseCmd(self, cmd):
        """
        param str cmd: command to be parsed
        """
        if cmd == '!quit':
            return 'STOP'

        elif cmd == '!help':
            self.print_welcome()
            return 'GO'

        elif cmd.startswith('!verbose'):
            (cmd, val) = cmd.split()
            if not val:
                print "No value specified"
                return 'GO'
            if val.lower() == 'off': self.SemParser.derivation = False ##
            elif val.lower() == 'on': self.SemParser.derivation = True ##
            else: print "Invalid value: {0}".format(val)
            return 'GO'

        elif cmd.startswith('!syntax'):
            (cmd, val) = cmd.split()
            if not val:
                print "No value specified"
                return 'GO'
            if val.lower() == 'off': self.SemParser.syntax = False ##
            elif val.lower() == 'on': self.SemParser.syntax = True ##
            else: print "Invalid value: {0}".format(val)
            return 'GO'

        elif cmd.startswith("!predlex"):
            (cmd, val) = cmd.split()
            if not val:
                return 'GO'
            for expr in self.SemParser.composer.predLex.get(val):
                print expr
            return 'GO'

        else:
            print "Unknown command: {0}".format(cmd)
            return 'GO'

    def printExpressions(self, expressions):
        print "======= SEMANTIC PARSES =======\n"
        if not expressions:
            print "None"
        else:
            for expr in expressions:
                print "+  {0}".format(expr)
            print ""

    def run(self):
        while self.status == 'GO':
            sent = raw_input("> ")

            # Command
            if sent.startswith('!'):
                self.status = self.parseCmd(sent)
            # Sentence
            else:
                expressions = self.SemParser.parse(sent)
                self.printExpressions(expressions)


if __name__ == '__main__':
    if not opts.ccglex or not opts.predlex:
        print "Usage: semparser [-v] [-s] --ccglex <path/to/file> \
               --predlex <path/to/file>"
        sys.exit(1)

    interpreter = Interpreter(opts.ccglex, opts.predlex,
                              opts.syntax, opts.verbose)
    interpreter.print_welcome()
    interpreter.run()
